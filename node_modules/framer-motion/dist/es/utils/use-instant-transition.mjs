<<<<<<< HEAD
import { useRef, useEffect } from 'react';
import { useInstantLayoutTransition } from '../projection/use-instant-layout-transition.mjs';
import { useForceUpdate } from './use-force-update.mjs';
import { instantAnimationState } from './use-instant-transition-state.mjs';
import { frame } from '../frameloop/frame.mjs';
=======
"use client";
import { frame } from 'motion-dom';
import { MotionGlobalConfig } from 'motion-utils';
import { useRef, useEffect } from 'react';
import { useInstantLayoutTransition } from '../projection/use-instant-layout-transition.mjs';
import { useForceUpdate } from './use-force-update.mjs';
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec

function useInstantTransition() {
    const [forceUpdate, forcedRenderCount] = useForceUpdate();
    const startInstantLayoutTransition = useInstantLayoutTransition();
    const unlockOnFrameRef = useRef(-1);
    useEffect(() => {
        /**
         * Unblock after two animation frames, otherwise this will unblock too soon.
         */
        frame.postRender(() => frame.postRender(() => {
            /**
             * If the callback has been called again after the effect
             * triggered this 2 frame delay, don't unblock animations. This
             * prevents the previous effect from unblocking the current
             * instant transition too soon. This becomes more likely when
             * used in conjunction with React.startTransition().
             */
            if (forcedRenderCount !== unlockOnFrameRef.current)
                return;
<<<<<<< HEAD
            instantAnimationState.current = false;
=======
            MotionGlobalConfig.instantAnimations = false;
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
        }));
    }, [forcedRenderCount]);
    return (callback) => {
        startInstantLayoutTransition(() => {
<<<<<<< HEAD
            instantAnimationState.current = true;
=======
            MotionGlobalConfig.instantAnimations = true;
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
            forceUpdate();
            callback();
            unlockOnFrameRef.current = forcedRenderCount + 1;
        });
    };
}
function disableInstantTransitions() {
<<<<<<< HEAD
    instantAnimationState.current = false;
}

export { disableInstantTransitions, useInstantTransition };
=======
    MotionGlobalConfig.instantAnimations = false;
}

export { disableInstantTransitions, useInstantTransition };
//# sourceMappingURL=use-instant-transition.mjs.map
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
