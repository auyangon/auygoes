import { noop } from 'motion-utils';
<<<<<<< HEAD
import { startViewAnimation } from './start.mjs';

/**
 * TODO:
 * - Create view transition on next tick
 * - Replace animations with Motion animations
 * - Return GroupAnimation on next tick
 */
class ViewTransitionBuilder {
    constructor(update, options = {}) {
        this.currentTarget = "root";
=======
import { addToQueue } from './queue.mjs';

class ViewTransitionBuilder {
    constructor(update, options = {}) {
        this.currentSubject = "root";
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
        this.targets = new Map();
        this.notifyReady = noop;
        this.readyPromise = new Promise((resolve) => {
            this.notifyReady = resolve;
        });
<<<<<<< HEAD
        queueMicrotask(() => {
            startViewAnimation(update, options, this.targets).then((animation) => this.notifyReady(animation));
        });
    }
    get(selector) {
        this.currentTarget = selector;
=======
        this.update = update;
        this.options = {
            interrupt: "wait",
            ...options,
        };
        addToQueue(this);
    }
    get(subject) {
        this.currentSubject = subject;
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
        return this;
    }
    layout(keyframes, options) {
        this.updateTarget("layout", keyframes, options);
        return this;
    }
    new(keyframes, options) {
        this.updateTarget("new", keyframes, options);
        return this;
    }
    old(keyframes, options) {
        this.updateTarget("old", keyframes, options);
        return this;
    }
    enter(keyframes, options) {
        this.updateTarget("enter", keyframes, options);
        return this;
    }
    exit(keyframes, options) {
        this.updateTarget("exit", keyframes, options);
        return this;
    }
    crossfade(options) {
        this.updateTarget("enter", { opacity: 1 }, options);
        this.updateTarget("exit", { opacity: 0 }, options);
        return this;
    }
    updateTarget(target, keyframes, options = {}) {
<<<<<<< HEAD
        const { currentTarget, targets } = this;
        if (!targets.has(currentTarget)) {
            targets.set(currentTarget, {});
        }
        const targetData = targets.get(currentTarget);
=======
        const { currentSubject, targets } = this;
        if (!targets.has(currentSubject)) {
            targets.set(currentSubject, {});
        }
        const targetData = targets.get(currentSubject);
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
        targetData[target] = { keyframes, options };
    }
    then(resolve, reject) {
        return this.readyPromise.then(resolve, reject);
    }
}
<<<<<<< HEAD
function view(update, defaultOptions = {}) {
    return new ViewTransitionBuilder(update, defaultOptions);
}

export { ViewTransitionBuilder, view };
=======
function animateView(update, defaultOptions = {}) {
    return new ViewTransitionBuilder(update, defaultOptions);
}

export { ViewTransitionBuilder, animateView };
//# sourceMappingURL=index.mjs.map
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
