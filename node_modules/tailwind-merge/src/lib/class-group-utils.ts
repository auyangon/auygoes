import {
    AnyClassGroupIds,
    AnyConfig,
    AnyThemeGroupIds,
    ClassGroup,
    ClassValidator,
    Config,
    ThemeGetter,
    ThemeObject,
} from './types'
<<<<<<< HEAD

export interface ClassPartObject {
    nextPart: Map<string, ClassPartObject>
    validators: ClassValidatorObject[]
    classGroupId?: AnyClassGroupIds
=======
import { concatArrays } from './utils'

export interface ClassPartObject {
    nextPart: Map<string, ClassPartObject>
    validators: ClassValidatorObject[] | null
    classGroupId: AnyClassGroupIds | undefined // Always define optional props for consistent shape
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
}

interface ClassValidatorObject {
    classGroupId: AnyClassGroupIds
    validator: ClassValidator
}

<<<<<<< HEAD
const CLASS_PART_SEPARATOR = '-'

=======
// Factory function ensures consistent object shapes
const createClassValidatorObject = (
    classGroupId: AnyClassGroupIds,
    validator: ClassValidator,
): ClassValidatorObject => ({
    classGroupId,
    validator,
})

// Factory ensures consistent ClassPartObject shape
const createClassPartObject = (
    nextPart: Map<string, ClassPartObject> = new Map(),
    validators: ClassValidatorObject[] | null = null,
    classGroupId?: AnyClassGroupIds,
): ClassPartObject => ({
    nextPart,
    validators,
    classGroupId,
})

const CLASS_PART_SEPARATOR = '-'

const EMPTY_CONFLICTS: readonly AnyClassGroupIds[] = []
// I use two dots here because one dot is used as prefix for class groups in plugins
const ARBITRARY_PROPERTY_PREFIX = 'arbitrary..'

>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
export const createClassGroupUtils = (config: AnyConfig) => {
    const classMap = createClassMap(config)
    const { conflictingClassGroups, conflictingClassGroupModifiers } = config

    const getClassGroupId = (className: string) => {
<<<<<<< HEAD
        const classParts = className.split(CLASS_PART_SEPARATOR)

        // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
        if (classParts[0] === '' && classParts.length !== 1) {
            classParts.shift()
        }

        return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className)
=======
        if (className.startsWith('[') && className.endsWith(']')) {
            return getGroupIdForArbitraryProperty(className)
        }

        const classParts = className.split(CLASS_PART_SEPARATOR)
        // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and skip it.
        const startIndex = classParts[0] === '' && classParts.length > 1 ? 1 : 0
        return getGroupRecursive(classParts, startIndex, classMap)
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
    }

    const getConflictingClassGroupIds = (
        classGroupId: AnyClassGroupIds,
        hasPostfixModifier: boolean,
<<<<<<< HEAD
    ) => {
        const conflicts = conflictingClassGroups[classGroupId] || []

        if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
            return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]!]
        }

        return conflicts
=======
    ): readonly AnyClassGroupIds[] => {
        if (hasPostfixModifier) {
            const modifierConflicts = conflictingClassGroupModifiers[classGroupId]
            const baseConflicts = conflictingClassGroups[classGroupId]

            if (modifierConflicts) {
                if (baseConflicts) {
                    // Merge base conflicts with modifier conflicts
                    return concatArrays(baseConflicts, modifierConflicts)
                }
                // Only modifier conflicts
                return modifierConflicts
            }
            // Fall back to without postfix if no modifier conflicts
            return baseConflicts || EMPTY_CONFLICTS
        }

        return conflictingClassGroups[classGroupId] || EMPTY_CONFLICTS
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
    }

    return {
        getClassGroupId,
        getConflictingClassGroupIds,
    }
}

const getGroupRecursive = (
    classParts: string[],
<<<<<<< HEAD
    classPartObject: ClassPartObject,
): AnyClassGroupIds | undefined => {
    if (classParts.length === 0) {
        return classPartObject.classGroupId
    }

    const currentClassPart = classParts[0]!
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart)
    const classGroupFromNextClassPart = nextClassPartObject
        ? getGroupRecursive(classParts.slice(1), nextClassPartObject)
        : undefined

    if (classGroupFromNextClassPart) {
        return classGroupFromNextClassPart
    }

    if (classPartObject.validators.length === 0) {
        return undefined
    }

    const classRest = classParts.join(CLASS_PART_SEPARATOR)

    return classPartObject.validators.find(({ validator }) => validator(classRest))?.classGroupId
}

const arbitraryPropertyRegex = /^\[(.+)\]$/

const getGroupIdForArbitraryProperty = (className: string) => {
    if (arbitraryPropertyRegex.test(className)) {
        const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)![1]
        const property = arbitraryPropertyClassName?.substring(
            0,
            arbitraryPropertyClassName.indexOf(':'),
        )

        if (property) {
            // I use two dots here because one dot is used as prefix for class groups in plugins
            return 'arbitrary..' + property
        }
    }
}

/**
 * Exported for testing only
 */
export const createClassMap = (config: Config<AnyClassGroupIds, AnyThemeGroupIds>) => {
    const { theme, prefix } = config
    const classMap: ClassPartObject = {
        nextPart: new Map<string, ClassPartObject>(),
        validators: [],
    }

    const prefixedClassGroupEntries = getPrefixedClassGroupEntries(
        Object.entries(config.classGroups),
        prefix,
    )

    prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
        processClassesRecursively(classGroup, classMap, classGroupId, theme)
    })

=======
    startIndex: number,
    classPartObject: ClassPartObject,
): AnyClassGroupIds | undefined => {
    const classPathsLength = classParts.length - startIndex
    if (classPathsLength === 0) {
        return classPartObject.classGroupId
    }

    const currentClassPart = classParts[startIndex]!
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart)

    if (nextClassPartObject) {
        const result = getGroupRecursive(classParts, startIndex + 1, nextClassPartObject)
        if (result) return result
    }

    const validators = classPartObject.validators
    if (validators === null) {
        return undefined
    }

    // Build classRest string efficiently by joining from startIndex onwards
    const classRest =
        startIndex === 0
            ? classParts.join(CLASS_PART_SEPARATOR)
            : classParts.slice(startIndex).join(CLASS_PART_SEPARATOR)
    const validatorsLength = validators.length

    for (let i = 0; i < validatorsLength; i++) {
        const validatorObj = validators[i]!
        if (validatorObj.validator(classRest)) {
            return validatorObj.classGroupId
        }
    }

    return undefined
}

/**
 * Get the class group ID for an arbitrary property.
 *
 * @param className - The class name to get the group ID for. Is expected to be string starting with `[` and ending with `]`.
 */
const getGroupIdForArbitraryProperty = (className: string): AnyClassGroupIds | undefined =>
    className.slice(1, -1).indexOf(':') === -1
        ? undefined
        : (() => {
              const content = className.slice(1, -1)
              const colonIndex = content.indexOf(':')
              const property = content.slice(0, colonIndex)
              return property ? ARBITRARY_PROPERTY_PREFIX + property : undefined
          })()

/**
 * Exported for testing only
 */
export const createClassMap = (config: Config<AnyClassGroupIds, AnyThemeGroupIds>) => {
    const { theme, classGroups } = config
    return processClassGroups(classGroups, theme)
}

// Split into separate functions to maintain monomorphic call sites
const processClassGroups = (
    classGroups: Record<AnyClassGroupIds, ClassGroup<AnyThemeGroupIds>>,
    theme: ThemeObject<AnyThemeGroupIds>,
): ClassPartObject => {
    const classMap = createClassPartObject()

    for (const classGroupId in classGroups) {
        const group = classGroups[classGroupId]!
        processClassesRecursively(group, classMap, classGroupId, theme)
    }

>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
    return classMap
}

const processClassesRecursively = (
    classGroup: ClassGroup<AnyThemeGroupIds>,
    classPartObject: ClassPartObject,
    classGroupId: AnyClassGroupIds,
    theme: ThemeObject<AnyThemeGroupIds>,
) => {
<<<<<<< HEAD
    classGroup.forEach((classDefinition) => {
        if (typeof classDefinition === 'string') {
            const classPartObjectToEdit =
                classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition)
            classPartObjectToEdit.classGroupId = classGroupId
            return
        }

        if (typeof classDefinition === 'function') {
            if (isThemeGetter(classDefinition)) {
                processClassesRecursively(
                    classDefinition(theme),
                    classPartObject,
                    classGroupId,
                    theme,
                )
                return
            }

            classPartObject.validators.push({
                validator: classDefinition,
                classGroupId,
            })

            return
        }

        Object.entries(classDefinition).forEach(([key, classGroup]) => {
            processClassesRecursively(
                classGroup,
                getPart(classPartObject, key),
                classGroupId,
                theme,
            )
        })
    })
}

const getPart = (classPartObject: ClassPartObject, path: string) => {
    let currentClassPartObject = classPartObject

    path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
        if (!currentClassPartObject.nextPart.has(pathPart)) {
            currentClassPartObject.nextPart.set(pathPart, {
                nextPart: new Map(),
                validators: [],
            })
        }

        currentClassPartObject = currentClassPartObject.nextPart.get(pathPart)!
    })

    return currentClassPartObject
}

const isThemeGetter = (func: ClassValidator | ThemeGetter): func is ThemeGetter =>
    (func as ThemeGetter).isThemeGetter

const getPrefixedClassGroupEntries = (
    classGroupEntries: Array<[classGroupId: string, classGroup: ClassGroup<AnyThemeGroupIds>]>,
    prefix: string | undefined,
): Array<[classGroupId: string, classGroup: ClassGroup<AnyThemeGroupIds>]> => {
    if (!prefix) {
        return classGroupEntries
    }

    return classGroupEntries.map(([classGroupId, classGroup]) => {
        const prefixedClassGroup = classGroup.map((classDefinition) => {
            if (typeof classDefinition === 'string') {
                return prefix + classDefinition
            }

            if (typeof classDefinition === 'object') {
                return Object.fromEntries(
                    Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]),
                )
            }

            return classDefinition
        })

        return [classGroupId, prefixedClassGroup]
    })
}
=======
    const len = classGroup.length
    for (let i = 0; i < len; i++) {
        const classDefinition = classGroup[i]!
        processClassDefinition(classDefinition, classPartObject, classGroupId, theme)
    }
}

// Split into separate functions for each type to maintain monomorphic call sites
const processClassDefinition = (
    classDefinition: ClassGroup<AnyThemeGroupIds>[number],
    classPartObject: ClassPartObject,
    classGroupId: AnyClassGroupIds,
    theme: ThemeObject<AnyThemeGroupIds>,
) => {
    if (typeof classDefinition === 'string') {
        processStringDefinition(classDefinition, classPartObject, classGroupId)
        return
    }

    if (typeof classDefinition === 'function') {
        processFunctionDefinition(classDefinition, classPartObject, classGroupId, theme)
        return
    }

    processObjectDefinition(
        classDefinition as Record<string, ClassGroup<AnyThemeGroupIds>>,
        classPartObject,
        classGroupId,
        theme,
    )
}

const processStringDefinition = (
    classDefinition: string,
    classPartObject: ClassPartObject,
    classGroupId: AnyClassGroupIds,
) => {
    const classPartObjectToEdit =
        classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition)
    classPartObjectToEdit.classGroupId = classGroupId
}

const processFunctionDefinition = (
    classDefinition: Function,
    classPartObject: ClassPartObject,
    classGroupId: AnyClassGroupIds,
    theme: ThemeObject<AnyThemeGroupIds>,
) => {
    if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme)
        return
    }

    if (classPartObject.validators === null) {
        classPartObject.validators = []
    }
    classPartObject.validators.push(
        createClassValidatorObject(classGroupId, classDefinition as ClassValidator),
    )
}

const processObjectDefinition = (
    classDefinition: Record<string, ClassGroup<AnyThemeGroupIds>>,
    classPartObject: ClassPartObject,
    classGroupId: AnyClassGroupIds,
    theme: ThemeObject<AnyThemeGroupIds>,
) => {
    const entries = Object.entries(classDefinition)
    const len = entries.length
    for (let i = 0; i < len; i++) {
        const [key, value] = entries[i]!
        processClassesRecursively(value, getPart(classPartObject, key), classGroupId, theme)
    }
}

const getPart = (classPartObject: ClassPartObject, path: string): ClassPartObject => {
    let current = classPartObject
    const parts = path.split(CLASS_PART_SEPARATOR)
    const len = parts.length

    for (let i = 0; i < len; i++) {
        const part = parts[i]!

        let next = current.nextPart.get(part)
        if (!next) {
            next = createClassPartObject()
            current.nextPart.set(part, next)
        }
        current = next
    }

    return current
}

// Type guard maintains monomorphic check
const isThemeGetter = (func: Function): func is ThemeGetter =>
    'isThemeGetter' in func && (func as ThemeGetter).isThemeGetter === true
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
