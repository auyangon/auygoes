<<<<<<< HEAD
import { AnyConfig } from './types'

export const IMPORTANT_MODIFIER = '!'

export const createParseClassName = (config: AnyConfig) => {
    const { separator, experimentalParseClassName } = config
    const isSeparatorSingleCharacter = separator.length === 1
    const firstSeparatorCharacter = separator[0]
    const separatorLength = separator.length

    // parseClassName inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
    const parseClassName = (className: string) => {
        const modifiers = []

        let bracketDepth = 0
        let modifierStart = 0
        let postfixModifierPosition: number | undefined

        for (let index = 0; index < className.length; index++) {
            let currentCharacter = className[index]

            if (bracketDepth === 0) {
                if (
                    currentCharacter === firstSeparatorCharacter &&
                    (isSeparatorSingleCharacter ||
                        className.slice(index, index + separatorLength) === separator)
                ) {
                    modifiers.push(className.slice(modifierStart, index))
                    modifierStart = index + separatorLength
=======
import { AnyConfig, ParsedClassName } from './types'

export const IMPORTANT_MODIFIER = '!'

const MODIFIER_SEPARATOR = ':'
const EMPTY_MODIFIERS: string[] = []

// Pre-allocated result object shape for consistency
const createResultObject = (
    modifiers: string[],
    hasImportantModifier: boolean,
    baseClassName: string,
    maybePostfixModifierPosition?: number,
    isExternal?: boolean,
): ParsedClassName => ({
    modifiers,
    hasImportantModifier,
    baseClassName,
    maybePostfixModifierPosition,
    isExternal,
})

export const createParseClassName = (config: AnyConfig) => {
    const { prefix, experimentalParseClassName } = config

    /**
     * Parse class name into parts.
     *
     * Inspired by `splitAtTopLevelOnly` used in Tailwind CSS
     * @see https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
     */
    let parseClassName = (className: string): ParsedClassName => {
        // Use simple array with push for better performance
        const modifiers: string[] = []

        let bracketDepth = 0
        let parenDepth = 0
        let modifierStart = 0
        let postfixModifierPosition: number | undefined

        const len = className.length
        for (let index = 0; index < len; index++) {
            const currentCharacter = className[index]!

            if (bracketDepth === 0 && parenDepth === 0) {
                if (currentCharacter === MODIFIER_SEPARATOR) {
                    modifiers.push(className.slice(modifierStart, index))
                    modifierStart = index + 1
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
                    continue
                }

                if (currentCharacter === '/') {
                    postfixModifierPosition = index
                    continue
                }
            }

<<<<<<< HEAD
            if (currentCharacter === '[') {
                bracketDepth++
            } else if (currentCharacter === ']') {
                bracketDepth--
            }
        }

        const baseClassNameWithImportantModifier =
            modifiers.length === 0 ? className : className.substring(modifierStart)
        const hasImportantModifier =
            baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER)
        const baseClassName = hasImportantModifier
            ? baseClassNameWithImportantModifier.substring(1)
            : baseClassNameWithImportantModifier
=======
            if (currentCharacter === '[') bracketDepth++
            else if (currentCharacter === ']') bracketDepth--
            else if (currentCharacter === '(') parenDepth++
            else if (currentCharacter === ')') parenDepth--
        }

        const baseClassNameWithImportantModifier =
            modifiers.length === 0 ? className : className.slice(modifierStart)

        // Inline important modifier check
        let baseClassName = baseClassNameWithImportantModifier
        let hasImportantModifier = false

        if (baseClassNameWithImportantModifier.endsWith(IMPORTANT_MODIFIER)) {
            baseClassName = baseClassNameWithImportantModifier.slice(0, -1)
            hasImportantModifier = true
        } else if (
            /**
             * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
             * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
             */
            baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER)
        ) {
            baseClassName = baseClassNameWithImportantModifier.slice(1)
            hasImportantModifier = true
        }
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec

        const maybePostfixModifierPosition =
            postfixModifierPosition && postfixModifierPosition > modifierStart
                ? postfixModifierPosition - modifierStart
                : undefined

<<<<<<< HEAD
        return {
=======
        return createResultObject(
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
            modifiers,
            hasImportantModifier,
            baseClassName,
            maybePostfixModifierPosition,
<<<<<<< HEAD
        }
    }

    if (experimentalParseClassName) {
        return (className: string) => experimentalParseClassName({ className, parseClassName })
=======
        )
    }

    if (prefix) {
        const fullPrefix = prefix + MODIFIER_SEPARATOR
        const parseClassNameOriginal = parseClassName
        parseClassName = (className: string) =>
            className.startsWith(fullPrefix)
                ? parseClassNameOriginal(className.slice(fullPrefix.length))
                : createResultObject(EMPTY_MODIFIERS, false, className, undefined, true)
    }

    if (experimentalParseClassName) {
        const parseClassNameOriginal = parseClassName
        parseClassName = (className: string) =>
            experimentalParseClassName({ className, parseClassName: parseClassNameOriginal })
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
    }

    return parseClassName
}
<<<<<<< HEAD

/**
 * Sorts modifiers according to following schema:
 * - Predefined modifiers are sorted alphabetically
 * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
 */
export const sortModifiers = (modifiers: string[]) => {
    if (modifiers.length <= 1) {
        return modifiers
    }

    const sortedModifiers: string[] = []
    let unsortedModifiers: string[] = []

    modifiers.forEach((modifier) => {
        const isArbitraryVariant = modifier[0] === '['

        if (isArbitraryVariant) {
            sortedModifiers.push(...unsortedModifiers.sort(), modifier)
            unsortedModifiers = []
        } else {
            unsortedModifiers.push(modifier)
        }
    })

    sortedModifiers.push(...unsortedModifiers.sort())

    return sortedModifiers
}
=======
>>>>>>> 7e787996e344ec0e38973ffd84b2419f9c179aec
